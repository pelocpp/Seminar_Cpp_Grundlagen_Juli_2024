==================================================

Guten Morgen

C++ Einführung
--------------

Donnerstag

Peter Loos

peter.loos@gmx.de

==================================================

Inhalt:

== Singleton

== Factory

== Catch2 // Testen

== Vorgehensweisen des Beispiel Quellcodes

== Schnittstellenkonzept

== Dependency Injection

== auto

== std::shared_ptr

== Lambda-Funktionen

== Frage: Callback-Zeiger wieder abbauen / freigeben

   ===> Lambda .... ===> geschachtelt ...


== std::bind


==================================================

Singleton

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/Singleton/Resources/Readme.md


getInstance ():   // gib mir ein Objekt

  a) Den Typ verstecken möchte.

  b) Nur EIN EINZIGES Objekt von dieser Klasse überhaupt hat: Singleton.

  c) Globales Objekt: Ginge ... Geschmäckle ...


  Details: Ist dieses EINE Objekt global verfügber
  
  Ist es dynamisch verfügbar.  // Speicherplatz

==================================================

Fabrik  // Factory

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/SimpleFactory/Resources/Readme.md


== Möchte ein Objekt haben

== Klasse dieses Objekts wird von jemand anders realisiert

   Time now;

   Die Realisierung dauert an .....

== Andere Möglichkeit:

   "Möchte ein Objekt haben"

   "Brauche ein paar Methoden mit einer gewissen Funktionalität"

   Spezifiziere diese Methoden mal ...
   Wie ???

   Eine Realisierung dieser Methoden bereitstellen:
   Wie ???

   In einer Klasse mit Vaterklasse

   Die SW wird auf diese Weise FLEXIBLER !!!

   Der Client bekommt dann nur die Methoden,
   die er in dieser / einer Schnittstelle spezifiziert hat.

------------------------------------------------------------

   Spezifiziere diese Methoden mal ...
   Wie ???
   "Schnittstelle"

   Schnittstellenklasse

   Häufig:  Nomenklatur: Namen von Schnittstellenklassen fangen mit 'I' an

    class IShape
    {
    public:
        virtual ~IShape() {}         // Detail

        virtual void draw() = 0;                // Methode 
        
        // virtual void eraseBackground() = 0;     // Methode 

        //private:
        //int m_data;   // No-go
    };

    // Schnittstelle  : Keyword interface: Java, C#,  Dart, .............
    interface IShape
    {
    public:
        virtual ~IShape() {}         // Detail

        abstract void draw();        // abstrakte Methode: Keine Realisierung 
    };

    Unterschiede: virtual,  = 0 <=========

    IShape ist datentechnisch eine Klasse

    Per Konzeption handelt es sich um einen Vertrag // Kontrakt :

    Was steht da drin:

    Das "jemand" eine Methode "void draw()" realisieren muss.

    "= 0";   // KEINE REALISIERUNG


------------------------------------------------------------


A) Schnittstellen
-----------------

Variante einer Schnittstelle:

B) Abstrakte Basisklasse
------------------------

Hat die Funktionalität einer Schnittstelle mit Ergänzungen:

i)  Daten (für alle Clients relevant sein)

ii) Teilweise Realisierung von Methoden, die für alle Clients relevant sein sollten / könnten.


------------------------------------------------------------



   Eine Realisierung dieser Methoden bereitstellen:
   Wie ???


    Via Vererbung:

    Eine Klasse "erbt" Methoden einer Vaterklasse.

    Was erbe ich in diesem Beispiel:

    "Nichts"   :-)

    Eine Aufgabe // eine Pflicht, die in einem einen Vertrag // Kontrakt beschrieben ist.

    'override' markiert Methoden, die den Vertrag erfüllen sollen.

    class Rectangle : public IShape   // !!!!!!!!!!!!!!!!!!!!!!!
    {
    public:
        Rectangle() {}

        void draw() override
        {
            std::cout << "> Rectangle::draw()" << std::endl;
        }
    };


    Detail:  Die Realisierung der Methode steht in der Klasse drin:

    "Geht auch ... wenn's schnell gehen muss"


'Rectangle::drawMe':

method with override specifier 'override' did not override any base class methods

=========================================================

Bemerkung:

Kann von einer Schnittstellenklasse KEIN Objekt anlegen!

Why ???

i) Eine Schnittstellenklasse ist abstrakt

ii) Eine Schnittstellenklasse ist unvollständig (per Konzeption)

=========================================================

Das "große Feature" des Schnittstellenkonzepts:

Entkopplung von Client und Service

An Stelle von realen Klassen arbeitet man mit

"Schnittstellenzeigern"

==================================================

"A programmer knows what he does"  :-)

==================================================

 Dependency Inversion:

 Was ist das ???

 In einem Satz:

 Miteinander gekoppelte / abhängige Klassen entkoppeln

 Wie?

 Durch eine Schnittstelle: Vertrag.

 Beide (vormals gekoppelte / abhängige Klassen) hängen
 nur nur von dieser Schnitttelle ab.

 ==================================================

 Blick in die Quellen:

class DialCallback : public IMakeCallCallback {
public:
    void makeCallResponse(ErrorCode error, std::shared_ptr<ICall> call) {


class IMakeCallCallback
{
    virtual void makeCallResponse(ErrorCode error, std::shared_ptr<ICall> call) = 0;
}

class DialCallback : public IMakeCallCallback {
public:
    virtual void makeCallResponse(ErrorCode error, std::shared_ptr<ICall> call) override {

======================================================================

Beobachtung:

std::shared_ptr<ICall> dialedCall = nullptr;

// ##### 5.1 Implement IMakeCallCallback interface to receive response for the dial request
// - optional
class DialCallback : public IMakeCallCallback {
public:
    void makeCallResponse(ErrorCode error, std::shared_ptr<ICall> call) {
       std::cout << "DialCallback::makeCallResponse" << std::endl;
       std::cout << "makeCallResponse ErrorCode: " << int(error) << std::endl;
       if(call) {
          std::cout << "makeCallResponse RemotePartyNumber : " << call->getRemotePartyNumber()
                    << std::endl;
          std::cout << "makeCallResponse getCallIndex : " << call->getCallIndex() << std::endl;
          dialedCall = call;
       }
    }
};


Zeiger wird außerhalb der Methode aufgerufen:

Geht das ?????????

Verliert der Zeiger seine Gültigkeit ??

NEIN: Weil es ein SHARED-PTR ist.

dialedCall = call

==========================================================

auto &phoneFactory = PhoneFactory::getInstance();

PhoneFactory& phoneFactory = PhoneFactory::getInstance();

PhoneFactory  &  phoneFactory = PhoneFactory::getInstance();


==========================================================

cpp_concurrency

Multi-Threading // Parallel-Programmierung

Collection of C++ examples to illustrate Concurrency Features



std::promise : Baukasten der C++ Multi-Threading Bibliothek

Wozu eigentlich dieses Multi-Threading  ???????????????

==> Funktion:  account.deposit(50);  // läuft die synchron 

                               // LANGE LAUFEN // Warten auf etwas // asynchron

std::promise: Hilfsmittel, um "zukünftige" Ergebnisse einzuholen 

std::future:  Gehört zum std::Promise 

============================================================


std::shared_ptr<ICallManager>  callManager = phoneFactory.getCallManager

// identisch zu

auto                           callManager = phoneFactory.getCallManager

(
   // Funktion ohne Namen // anonym // Lambda-Objekt
   [&] (telux::common::ServiceStatus status) { cbProm.set_value(status); }
            
);

==============================================================

auto:  Ist eine abkürzende Schreibweise

==============================================================

std::shared_ptr

release ();

How to release a shared pointer:


// 99%
dialedCall = nullptr;

==============================================================

auto:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Auto/Auto.md

==============================================================

Lamdba-Funktionen:
------------------

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Lambda/Lambda.md


Sind von anderen Sprachen populär gemacht worden ( C#, Java, JavaScript, ...)

..... und damit in C++ aufgenommen worden :-)

Beispiel:

std::vector<int> vec{ 5, 6, 4, 1, 3, 2, 7, 8 };

Ist quasi ein Array

int numbers[10];

(( C-Array:  FIXED-Size         ))
(( STL:      VARIABLE-Sized     ))

Beispiel:   std::sort

C/C++-Funktion:   

Der als Parameter eine ANDERE Funktion übergeben wird.    // Callback-Funktion

A) ERSTE VARIANTE:  C-Funktion

std::sort(
    std::begin(vec), 
    std::end(vec),
    compare
);


bool compare(int n1, int n2) {    // reg. C-Funktion  
        return n1 < n2;
}

B) ZWEITE VARIANTE:  "Aufrufbares Objekt" // Callable // Functor


   Klasse // Objekt das dem Aufruf-Operator operator() realisiert.


C) DRITTE  VARIANTE:  Lambda:   Methoden OHNE Namen // anonym 

Weil Lambdas == "Aufrufbares Objekt", deren Klassen und Objekte
       der Compiler erzeugt:

       Klasse: Übersetzungszeit
       Objekt: Aufgerufen zur Laufzeit.


SYNTAX: ?????????????????????????

BEMERKUNG:   

Typischerweise: Lambda-Funktion

EXAKT: FALSCH  // Lambda-Objekt

================================================================

Komplexität:

Lambda

Klausel

Shared-Pointer



ABER:

Es gibt Sonne am Horizont:

ICallback


ICallback*

sondern

std::shared_ptr<ICallback>

// ===============================================================

== std::shared_ptr

// ===============================================================

Smart Pointer 

Dynamische Speicherverwaltung:

new
===> Reserviert Speicher : Halde / Haufen / Heap

Freigabe:
===> delete : Hebt die Reserierung auf.

Idee:

A) Objekt-Orientierung:

Konstruktoren:
Destruktoren:

Aufruf ist DETERMINISTISCH : 

Erzeugung: Beim Erzeugen
Destruktor:  Wenn das Objekt aus dem Scope fällt ("wenn die Funktion verlassen wird")

B) Zeiger-Variable:

int* ip;

ip1 = new int;       // eine int-Variable
ip2 = new int[100];  // ein Feld von int-Variablen

delete   ip1;  // scalar-delete
delete[] ip2;  // array-delete

C) Wem gehört der Zeiger // Wer ist der Besitzer der Zeigers ???

   Ownership  ===> delete

D) Idee:  Das new // den Zeiger in einer Hüllen-Klasse ablegen

          Den Zeiger einer Hüllen-Klasse übergeben.

Konstruktor:  new
Destruktor:   delete

E) auto_ptr:  deprecated

F) std::unique_ptr
   std::shared_ptr

   std::weak_ptr

G) Strategien:

Ownership std::unique_ptr:  EXKLUSIVE Besitz.

    Zu EINEM Zeitpunkt gibt es EINEN Besitzer.

    // Dieses Hüllen-Objekt ist NICHT kopierbar.


Ownership std::shared_ptr:  GETEILTE Besitz / Mehrere Besitzer.

H) Beispiel:

Callback-Objekte:

Client damit "später" Informationen erhalten kann:

a) Anwendung / Client  ==> Gibt das Hüllenobjekt frei
b) Der Verwender / das Zielobjekt ==> Gibt das Hüllenobjekt frei

Clou: Wenn ALLE Besitzer das Hüllenobjekt freigegeben haben:  delete

// =========================================================

std::unique_ptr:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/UniquePtr/UniquePtr.md

// =========================================================

Verschiebe-Semantik:

Laufzeit-Verbesserung: C++ 11 

// =========================================================

Nebeneffekt:

Laufzeit Laufzeit ...

Optimierungen:

RVO  ==> Return Value Optimization

NRVO  ==> Return Named Value Optimization

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/CopyMoveElision/CopyMoveElision.md


// =========================================================

std::shared:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/SharedPtr/SharedPtr.md


// =========================================================


A) Frage:

Das Abmelden von Callbacks / Listenern:

Ziel:

attach (...);  // Lambda // shared-Ptr

detach ();

    static void test_frage()
    {
        std::shared_ptr<int> ptr{ new int{ 123 } };
        std::shared_ptr<int> ptr2 { ptr };

        ptr = nullptr;
    }



B) Scharfes Schwert:
------------------


std::get_deleter

template< class Deleter, class T >
Deleter* get_deleter( const std::shared_ptr<T>& p ) noexcept;

Einklinken // Dazwischen schalten:


Da kann man dann den Fall des Zählers von 1 auf 0 beobachten.



C) RAII Idiom:
---------------

Man kann so einen Shared-Pointer auch selbst schreiben:

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/RAII_Idiom/Resources/Readme.md

Verwaltet Resourcen:

Konstruktor
Destruktor

===>

Wann immer ein Callback / kritisches Argument weitergereicht wird:

Hüllenobjekt weitergereicht.

// =================================================================

Zu Callbacks:

Observer:

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/Observer/Resources/Readme.md


    class ISubject {
    public:
        virtual ~ISubject() {}

        virtual void attach(IObserver* observer) = 0;
        virtual void detach(IObserver* observer) = 0;
    };


// =================================================================

Zu Callbacks:

Intercepting Filter Pattern

https://github.com/pelocpp/cpp_design_patterns/blob/master/Patterns/InterceptingFilterPattern/Resources/Readme.md

Das Intercepting Filter Pattern ist ein Entwurfsmuster
das sich der Vor- und Nachbearbeitung einer Anforderung („Request”, typischerweise ein Methodenaufruf) zuwendet.

Die Vor- und Nachbearbeitung definiert Aktionen,
die vor und nach der Kernverarbeitung der Anforderung ausgeführt werden.


// =================================================================

Testen:

C++  Catch2

https://github.com/catchorg/Catch2

// =================================================================
